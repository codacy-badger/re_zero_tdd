:toc: left
:toclevels: 5
:sectnums:

= 見知らぬ、構造化プログラミング

== 概要
=== 実施日時
* https://hiroshima-arc.connpass.com/event/109589/[2018年11月16日（金） 18:00 - 21:00]

=== 会場

++++
<iframe src="https://www.google.com/maps/embed?pb=!1m14!1m8!1m3!1d6584.583947396631!2d132.458662!3d34.393924!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x0%3A0xe874ed70577dcf46!2z44Kz44Ov44O844Kt44Oz44Kw44K544Oa44O844K5IFNoYWtlSGFuZHM!5e0!3m2!1sja!2sjp!4v1541923570346" width="400" height="300" frameborder="0" style="border:0" allowfullscreen></iframe>
++++

=== 参加メンバー
* https://portfolio.forkwell.com/@k2works[テストおじさん]
* リモートさん
* テスト鬼さん
* テスト初めて書いたひと

=== お題
* http://www.hiroshima-arc.org/re_zero_tdd/fizz_buzz.html[FizzBuzz]
* FizzBuzz をクラスを使わずにテスト駆動で実装する。

=== 言語
* Python 3.6

== セッション

=== 前回までのあらすじ

http://www.hiroshima-arc.org/re_zero_tdd/session/20181109.html#_problem[前回のセッション]でクラスベースだとオブジェクト指向に関する解説も必要になることがわかったテストおじさん。

そこで今回はクラスを使わずにテスト駆動開発をやってみることにしたのであった。

さてさてどうなることやら・・・

=== TODOリストから始めるアジャイルソフトウェア開発

==== 仕様

*テストおじさん*: はい、第２回 Re:ゼロから始めるテスト駆動開発 はじめます、レポジトリは https://github.com/hiroshima-arc/re_zero_tdd[ここ]ね。

*リモートさん*: 今日は家からうっすら参加です。ご飯を食べたりで適当に抜けています。

*テスト鬼さん*: よろしくお願いします。

*テスト初めて書いたひと*: よろしくお願いします。

*テストおじさん*: 今日はFizzBuzzをクラスを使わずにテスト駆動で実装してみたいと思います。

*テストおじさん*: 今回のお題の仕様です。

> 1 から 100 までの数をプリントするプログラムを書け。
> ただし 3 の倍数のときは数の代わりに｢Fizz｣と、5 の倍数のときは｢Buzz｣とプリントし、3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。

*テストおじさん*: http://www.hiroshima-arc.org/re_zero_tdd/session/20181109.html#_%E3%82%BB%E3%83%83%E3%82%B7%E3%83%A7%E3%83%B3[前回のセッション]との違いとして今回はコンソールに出力させるというのが大きな違いですかね。

==== TODOリスト

*テストおじさん*: 最初にまず [red]#TODOリスト# の作成をしましょう。

[quote, 'https://amzn.to/2QtCA5b[テスト駆動開発]']
____
TODOリスト

何をテストすべきだろうか----着手する前に、必要になりそうなテストをリストに書き出しておこう。
____

*テストおじさん*: 仕様からTODOリストを作成するわけですがここは [red]#一つのプログラムには一つのことをうまくやらせる# の原則に従ってシンプルにやってみましょう。

TODOリストを書き出すテストおじさん。

* [ ] 1 から 100 まで数をプリントできるようにする。
* [ ] 3 の倍数のときは数の代わりに｢Fizz｣をプリントできるようにする。
* [ ] 5 の倍数のときは｢Buzz｣とプリントできるようにする。
* [ ] 3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントできるようにする。

*テストおじさん*: まずは100回繰り返し処理をすることをどうやって実装するかを考えるとして条件に関しては一旦置いておきましょう。

*テストおじさん*: 一つのTODOには一つのことをテストできるようにする・・・みたいな。

==== アジャイルソフトウェア開発

*テスト鬼さん*: TODOリストの粒度はどれくらいが適切なんですかね？

*テストおじさん*: 自分はテストメソッドに対応するぐらいを目安に書いてますね。

*テスト初めて書いたひと*: 実際の開発だとTODOリストの粒度って立場によって変わってくると思うんですがどう取りまとめて行けばいいんですかね？

*テストおじさん*: そうですよね、作業者レベルのTODOもアプリケーションの要求から落とし込まないといけませよね。

*テストおじさん*: そういったものをどう取り扱うかは [red]#アジャイルソフトウェア開発手法# が参考になるかと思います。

*テスト初めて書いたひと*: アジャイル?

*テストおじさん*: えーとです、例えば今日のお題の仕様ですが。

> 1 から 100 までの数をプリントするプログラムを書け。
> ただし 3 の倍数のときは数の代わりに｢Fizz｣と、5 の倍数のときは｢Buzz｣とプリントし、3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。

*テストおじさん*: これが

> [red]#1 から 1000# までの数をプリントするプログラムを書け。
> ただし 3 の倍数のときは数の代わりに｢Fizz｣と、5 の倍数のときは｢Buzz｣とプリントし、3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。

*テストおじさん*: とか

> [red]#1 から 1000# までの数をプリントするプログラムを書け。
> ただし 3 の倍数のときは数の代わりに [red]#｢FizzFizzFizz｣# と、5 の倍数のときは [red]#｢BuzzBuzzBuzz｣# とプリントし、3 と 5 両方の倍数の場合には [red]#｢FizzBuzzFizzBuzzFizzBuzz｣# とプリントすること。
> [red]#ただし、上記の処理は月初のみに行うこと。#

*テストおじさん*: からの

> [red]#1 から 1000# までの数をプリントするプログラムを書け。
> ただし 3 の倍数のときは数の代わりに [red]#｢FizzFizzFizz｣# と、5 の倍数のときは [red]#｢BuzzBuzzBuzz｣# とプリントし、3 と 5 両方の倍数の場合には [red]#｢FizzBuzzFizzBuzzFizzBuzz｣# とプリントすること。
> [red]#ただし、上記の処理は月初のみに行うこと。#
> [red]#上記の仕様は現状のビジネスモデルの変更に伴い無効とする。#

*テスト鬼さん*: !

*テスト初めて書いたひと*: !!

*テストおじさん*: みたいに仕様が確定した後もコロコロ変わっていくと従来型の開発アプローチでは対応が難しいですよね。

*テストおじさん*: そういったビジネスとITの変化が [red]#アジャイルソフトウェア開発宣言# につながることになりました。

[quote, 'http://agilemanifesto.org/iso/ja/manifesto.html[アジャイルソフトウェア開発宣言]']
____

私たちは、ソフトウェア開発の実践

あるいは実践を手助けをする活動を通じて、

よりよい開発方法を見つけだそうとしている。

この活動を通して、私たちは以下の価値に至った。

プロセスやツールよりも個人と対話を、

包括的なドキュメントよりも動くソフトウェアを、

契約交渉よりも顧客との協調を、

計画に従うことよりも変化への対応を、

価値とする。すなわち、左記のことがらに価値があることを

認めながらも、私たちは右記のことがらにより価値をおく。
____

*テストおじさん*: そして [red]#アジャイル宣言の背後にある原則# を実現するための手法として [red]#XP（eXtreme Programming）# や [red]#スクラム# があります。

[quote, 'http://agilemanifesto.org/iso/ja/principles.html[アジャイル宣言の背後にある原則]']
____
私たちは以下の原則に従う:

顧客満足を最優先し、
価値のあるソフトウェアを早く継続的に提供します。

要求の変更はたとえ開発の後期であっても歓迎します。
変化を味方につけることによって、お客様の競争力を引き上げます。

動くソフトウェアを、2-3週間から2-3ヶ月という
できるだけ短い時間間隔でリリースします。

ビジネス側の人と開発者は、プロジェクトを通して
日々一緒に働かなければなりません。

意欲に満ちた人々を集めてプロジェクトを構成します。
環境と支援を与え仕事が無事終わるまで彼らを信頼します。

情報を伝えるもっとも効率的で効果的な方法は
フェイス・トゥ・フェイスで話をすることです。

動くソフトウェアこそが進捗の最も重要な尺度です。

アジャイル･プロセスは持続可能な開発を促進します。
一定のペースを継続的に維持できるようにしなければなりません。

技術的卓越性と優れた設計に対する
不断の注意が機敏さを高めます。

シンプルさ（ムダなく作れる量を最大限にすること）が本質です。

最良のアーキテクチャ・要求・設計は、
自己組織的なチームから生み出されます。

チームがもっと効率を高めることができるかを定期的に振り返り、
それに基づいて自分たちのやり方を最適に調整します。
____

*テストおじさん*: 要求をソフトウェアに落とし込むためのプラクティスとして [red]#ストーリー# や [red]#プロダクトバックログ# [red]#スプリントバックログ# なんてのがありますね。

*テストおじさん*: プログラムマ目線なら [red]#TODOリスト# は [red]#スプリントバックログ# より細かい粒度になるんじゃないかなと思ってます。

*テスト初めて書いたひと*: [red]#TODOリスト# に抜けや漏れがあった場合はどうするんですかね?

> 要求の変更はたとえ開発の後期であっても歓迎します。
> 変化を味方につけることによって、お客様の競争力を引き上げます。

*テストおじさん*: の原則に従い、[red]#テストファーストプログラミング# と [red]#インクリメンタルな設計# で [red]#TODOリスト# の抜けを埋めて漏れを塞ぎましょう。

=== テストファーストから始めるアーキテクチャ

==== テストファースト

*テストおじさん*: では1つ目の [red]#TODOリスト# から片付けていきましょうか。

ファイルを新規作成するテストおじさん。

*テストおじさん*: まずは [red]#テストファースト# で。

[source, bash]
----
 $ python main_test.py -v

 ----------------------------------------------------------------------
 Ran 0 tests in 0.000s

 OK
----

[quote, 'https://amzn.to/2QtCA5b[テスト駆動開発]']
____
テストファースト

いつテストを書くべきだろうか----それはテスト対象のコードを書く前だ。
____

==== アサートファースト

*テストおじさん*: さて、1から100までコンソールに出力させないといけませんがまずは [red]#アサートファースト# で [red]#仮実装# を行ってテストを通しておきましょう。

[quote, 'https://amzn.to/2QtCA5b[テスト駆動開発]']
____
アサートファースト

いつアサーションを書くべきだろうか----最初に書こう

* システム構築はどこから始めるべきだろうか。システム構築が終わったらこうなる、というストーリーを語るところからだ。
* 機能はどこから書き始めるべきだろうか。コードが書き終わったらこのように動く、というテストを書くところからだ。
* ではテストはどこから書き始めるべきだろうか。それはテストの終わりにパスすべきアサーションを書くところからだ。
____

[quote, 'https://amzn.to/2QtCA5b[テスト駆動開発]']
____
仮実装を経て本実装へ

失敗するテストを書いてから、最初に行う実装はどのようなものだろうか----ベタ書きの値を返そう。
____

*テストおじさん*: はい、オッケー。

[source, bash]
----
 $ python main_test.py -v
 test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok

 ----------------------------------------------------------------------
 Ran 1 test in 0.000s

 OK
----

*テスト鬼さん*: `-v` のオプションは？

*テストおじさん*: これは実施するテストを表示するオプションです。

*テストおじさん*: オプションなしで実行すると。

[source, bash]
----
 $ python main_test.py
 .
 ----------------------------------------------------------------------
 Ran 1 test in 0.000s

 OK
----

*テストおじさん*: こんな感じになります。

==== 仮実装

コードを書き換えてテストを実行するテストをおじさん。

[source, Python]
----
def execute():
    print(1)
----

[source, bash]
----
 python main_test.py
1
F
======================================================================
FAIL: test_1から100まで数をプリントできるようにする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 10, in test_1から100まで数をプリントできるようにする
    self.assertEqual("1", execute())
AssertionError: '1' != None

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
----

*テストおじさん*: 1をコンソールに出力はできたけど結果をどうやってアサーションしましょうかね。

*テストおじさん*: だいたいこんな時私は https://www.google.com/search?q=Python+unittest+%E6%A8%99%E6%BA%96%E5%87%BA%E5%8A%9B&ie=utf-8&oe=utf-8&client=firefox-b-ab[Python unittest 標準出力] みたいなキーワードでググります。

*テストおじさん*: いくつかの記事を眺めて良さげなのを試します。

*テストおじさん*: 今回は https://qiita.com/Asayu123/items/6f2471aa5ebe597b2638[こちらのQiitaの記事] を参考にさせていただきましょう。

いくつかコードを追記するテストおじさん

[source, Python]
----
import unittest
from test.support import captured_stdout


def execute():
    print(1)


class MainTest(unittest.TestCase):
    def test_1から100まで数をプリントできるようにする(self):
        with captured_stdout() as stdout:
            execute()
        self.assertEqual("1", stdout.getvalue())
----

*テストおじさん*: こうかな・・・テスト!

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... FAIL

======================================================================
FAIL: test_1から100まで数をプリントできるようにする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 13, in test_1から100まで数をプリントできるようにする
    self.assertEqual("1", stdout.getvalue())
AssertionError: '1' != '1\n'
- 1
+ 1

?   +


----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
----

*テストおじさん*: ありゃ、えーと `AssertionError: '1' != '1\n'` ・・・ふむ、改行されて出力されるのね。

[source, Python]
----
class MainTest(unittest.TestCase):
    def test_1から100まで数をプリントできるようにする(self):
        with captured_stdout() as stdout:
            execute()
        self.assertEqual("1\n", stdout.getvalue())
----

*テストおじさん*: これで・・・オッケー。

[source, bash]
----
 $ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok

----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
----

==== 三角測量

*テストおじさん*: さて、アサーションができようになったので [red]#while文# の制御構造を使って繰り返し実行の処理を実装してみましょう。

[source, Python]
----
def execute():
    n = 100
    while n != 0:
        print(n)
----

*テストおじさん*: はい、実行・・・おや？

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ...
----

*テストおじさん*: はい nがマイナスされないので `n != 0` の条件になることができず無限ループに入ってますね。

[source, Python]
----
def execute():
    n = 100
    while n != 0:
        print(n)
        n = n - 1
----

*テストおじさん*: これで、実行!

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... FAIL

======================================================================
FAIL: test_1から100まで数をプリントできるようにする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 16, in test_1から100まで数をプリントできるようにする
    self.assertEqual("1\n", stdout.getvalue())
AssertionError: '1\n' != '100\n99\n98\n97\n96\n95\n94\n93\n92\n91\n9[346 chars]n1\n'
+ 100
+ 99
+ 98
+ 97
+ 96
+ 95
+ 94
+ 93
+ 92
+ 91
+ 90
+ 89
+ 88
+ 87
+ 86
+ 85
+ 84
+ 83
+ 82
+ 81
+ 80
+ 79
+ 78
+ 77
+ 76
+ 75
+ 74
+ 73
+ 72
+ 71
+ 70
+ 69
+ 68
+ 67
+ 66
+ 65
+ 64
+ 63
+ 62
+ 61
+ 60
+ 59
+ 58
+ 57
+ 56
+ 55
+ 54
+ 53
+ 52
+ 51
+ 50
+ 49
+ 48
+ 47
+ 46
+ 45
+ 44
+ 43
+ 42
+ 41
+ 40
+ 39
+ 38
+ 37
+ 36
+ 35
+ 34
+ 33
+ 32
+ 31
+ 30
+ 29
+ 28
+ 27
+ 26
+ 25
+ 24
+ 23
+ 22
+ 21
+ 20
+ 19
+ 18
+ 17
+ 16
+ 15
+ 14
+ 13
+ 12
+ 11
+ 10
+ 9
+ 8
+ 7
+ 6
+ 5
+ 4
+ 3
+ 2
  1


----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
----

*テストおじさん*: 100まで出力できたけど今度はアサーションをどうしましょうかね。

*テストおじさん*: https://qiita.com/Asayu123/items/6f2471aa5ebe597b2638[先程参考にした記事] に実行結果を [red]#リスト(list)# に格納する方法が書いてあったので使わせていただきましょう。

[source, Python]
----
class MainTest(unittest.TestCase):
    def test_1から100まで数をプリントできるようにする(self):
        with captured_stdout() as stdout:
            execute()
            lines = stdout.getvalue().splitlines()

        self.assertEqual("1\n", lines[1])
----

*テストおじさん*: これでどうかな?

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... FAIL

======================================================================
FAIL: test_1から100まで数をプリントできるようにする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 18, in test_1から100まで数をプリントできるようにする
    self.assertEqual("1\n", lines[1])
AssertionError: '1\n' != '99'
- 1
+ 99

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
----

*テストおじさん*: おや？ `AssertionError: '1\n' != '99'` ・・・改行コードはいらないのね・・・99?

デバッガを実行して `lines` を確認するテストおじさん。

*テストおじさん*: あーそうか、100から出力されてるからね。

[source, Python]
----
        self.assertEqual("1", lines[100])
----

*テストおじさん*: こうか！

[source, bash]
----
 $ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ERROR

======================================================================
ERROR: test_1から100まで数をプリントできるようにする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 18, in test_1から100まで数をプリントできるようにする
    self.assertEqual("1", lines[100])
IndexError: list index out of range

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (errors=1)
----

*テストおじさん*: ファッ!? `IndexError: list index out of range` ・・・あー [red]#リスト(list)# は0から始まる仕様だったな。

*テストおじさん*: こうね。

[source, Python]
----
        self.assertEqual("1", lines[99])
----

*テストおじさん*: オッケー!

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok

----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
----

*テストおじさん*: [red]#三角測量# を実施して100が出力していることも確認しておきましょう。

[quote, 'https://amzn.to/2QtCA5b[テスト駆動開発]']
____
三角測量

テストから最も慎重に一般化を引き出すやり方はどのようなものだろうか----２つ以上の例があるときだけ、一般化を行うようにしよう。
____

*テストおじさん*: 一番最初のリストの添字は0だから・・・

[source, Python]
----
    def test_1から100まで数をプリントできるようにする(self):
        with captured_stdout() as stdout:
            execute()
            lines = stdout.getvalue().splitlines()

        self.assertEqual("1", lines[99])
        self.assertEqual("100", lines[0])
----

*テストおじさん*: はい、オッケー!

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok

----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
----

*テストおじさん*: [red]#TODOリスト# 一つ目を片付けることができました。

* [x] 1 から 100 まで数をプリントできるようにする。
* [ ] 3 の倍数のときは数の代わりに｢Fizz｣をプリントできるようにする。
* [ ] 5 の倍数のときは｢Buzz｣とプリントできるようにする。
* [ ] 3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントできるようにする。

==== 明白な実装

*テストおじさん*: さて、　二つ目の [red]#TODOリスト# に取り掛かるとしましょうか。

テストコードを追加するテストおじさん。

[source, Python]
----
    def test_3の倍数のときは数の代わりにFizzをプリントする(self):
        with captured_stdout() as stdout:
            execute()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("Fizz", lines[97])
----

*テストおじさん*: テストは・・・失敗するね、オッケー。

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... FAIL

======================================================================
FAIL: test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 25, in test_3の倍数のときは数の代わりにFizzをプリントする
    self.assertEqual("Fizz", lines[97])
AssertionError: 'Fizz' != '3'
- Fizz
+ 3


----------------------------------------------------------------------
Ran 2 tests in 0.001s

FAILED (failures=1)
----

*テスト初めて書いたひと*: テストが失敗するのにオッケーだと!?

ニヤリと笑うテストおじさん。

*テストおじさん*: お忘れなく・・・今やっていることはテストではなく設計だということ。

[quote, 'https://amzn.to/2QtCA5b[テスト駆動開発]']
____
皮肉なことに、TDDはテスト技法ではない（Cunninghamの公案)。TDDは分析技法であり、設計技法であり、実際には開発のすべてのアクティビティを構造化する技法なのだ。
____

*テストおじさん*: さて、では設計を満たす振る舞いを [red]#明白な実装# しましょう。

[source, Python]
----
def execute():
    n = 100
    while n != 0:
        if n % 3 == 0:
            print("Fizz")
        print(n)
        n = n - 1
----

*テストおじさん*: えい!

[source, bash]
----
 $ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... FAIL
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... ok

======================================================================
FAIL: test_1から100まで数をプリントできるようにする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 20, in test_1から100まで数をプリントできるようにする
    self.assertEqual("1", lines[99])
AssertionError: '1' != '26'
- 1
+ 26


----------------------------------------------------------------------
Ran 2 tests in 0.001s

FAILED (failures=1)
----

*テストおじさん*: おや、最初のテストが失敗してしまいました。

変更箇所を眺めるテストおじさん。

[source, Python]
----
def execute():
    n = 100
    while n != 0:
        if n % 3 == 0:
            print("Fizz") <1>
        print(n) <2>
        n = n - 1
----

*テストおじさん*: あー、printが２回実行されてますね。

*テストおじさん*: ここはこうで・・・

[source, Python]
----
def execute():
    n = 100
    while n != 0:
        if n % 3 == 0:
            print("Fizz")
        else:
            print(n)
        n = n - 1
----

*テストおじさん*: こう！

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.001s

OK
----

*テストおじさん*: [red]#TODOリスト# 二つ目を片付けることができました。

* [x] 1 から 100 まで数をプリントできるようにする。
* [x] 3 の倍数のときは数の代わりに｢Fizz｣をプリントできるようにする。
* [ ] 5 の倍数のときは｢Buzz｣とプリントできるようにする。
* [ ] 3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントできるようにする。

*テストおじさん*: さて、　三つ目の [red]#TODOリスト# に取り掛かるとしましょうか。

*テストおじさん*: まずはテスト・・・もとい、設計でしたね。

[source, Python]
----
    def test_5の倍数のときはBuzzとプリントする(self):
        with captured_stdout() as stdout:
            execute()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("Buzz", lines[95])
----

*テストおじさん*: テストは・・・失敗すると。

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (__main__.MainTest) ... FAIL

======================================================================
FAIL: test_5の倍数のときはBuzzとプリントする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 34, in test_5の倍数のときはBuzzとプリントする
    self.assertEqual("Buzz", lines[95])
AssertionError: 'Buzz' != '5'
- Buzz
+ 5


----------------------------------------------------------------------
Ran 3 tests in 0.001s

FAILED (failures=1)
----

*テストおじさん*: ５の場合はBuzzをプリントするから。

[source, Python]
----
def execute():
    n = 100
    while n != 0:
        if n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
        n = n - 1
----

*テストおじさん*: これでどうかな?

[source, bash]
----
 $ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... FAIL
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (__main__.MainTest) ... ok

======================================================================
FAIL: test_1から100まで数をプリントできるようにする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 24, in test_1から100まで数をプリントできるようにする
    self.assertEqual("100", lines[0])
AssertionError: '100' != 'Buzz'
- 100
+ Buzz


----------------------------------------------------------------------
Ran 3 tests in 0.001s

FAILED (failures=1)
----

*テストおじさん*: 最初のテストが失敗してますね。えーと、 `AssertionError: '100' != 'Buzz'` ・・・

*テストおじさん*: 100は5で割り切れるからBuzzを返すのが正しい仕様ですね、修正しましょう。

[source, Python]
----
    def test_1から100まで数をプリントできるようにする(self):
        with captured_stdout() as stdout:
            execute()
            lines = stdout.getvalue().splitlines()

        self.assertEqual("1", lines[99])
        self.assertEqual("Buzz", lines[0]) <1>
----

*テストおじさん*: はい、オッケーっと。

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (__main__.MainTest) ... ok

----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK
----

*テストおじさん*: [red]#TODOリスト# 三つ目を片付けることができました。

* [x] 1 から 100 まで数をプリントできるようにする。
* [x] 3 の倍数のときは数の代わりに｢Fizz｣をプリントできるようにする。
* [x] 5 の倍数のときは｢Buzz｣とプリントできるようにする。
* [ ] 3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントできるようにする。

*テストおじさん*: さて、　最後の [red]#TODOリスト# に取り掛かるとしましょうか。

*テストおじさん*: まずは、テスコードという名の設計をしてと。

[source, Python]
----
    def test_3と5両方の倍数の場合にはFizzBuzzとプリントする(self):
        with captured_stdout() as stdout:
            execute()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("FizzBuzz", lines[85])
----

*テストおじさん*: 確認。

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (__main__.MainTest) ... FAIL
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (__main__.MainTest) ... ok

======================================================================
FAIL: test_3と5両方の倍数の場合にはFizzBuzzとプリントする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 42, in test_3と5両方の倍数の場合にはFizzBuzzとプリントする
    self.assertEqual("FizzBuzz", lines[85])
AssertionError: 'FizzBuzz' != 'Fizz'
- FizzBuzz
+ Fizz


----------------------------------------------------------------------
Ran 4 tests in 0.001s

FAILED (failures=1)
----

*テストおじさん*: 3で割り切れてかつ5で割り切れるから。

[source, Python]
----
def execute():
    n = 100
    while n != 0:
        if n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        elif n % 3 == 0 and n % 5 == 0: <1>
            print("FizzBuzz")
        else:
            print(n)
        n = n - 1
----

*テストおじさん*: どうなるかな?

[source, bash]
----
 $ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (__main__.MainTest) ... FAIL
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (__main__.MainTest) ... ok

======================================================================
FAIL: test_3と5両方の倍数の場合にはFizzBuzzとプリントする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 44, in test_3と5両方の倍数の場合にはFizzBuzzとプリントする
    self.assertEqual("FizzBuzz", lines[85])
AssertionError: 'FizzBuzz' != 'Fizz'
- FizzBuzz
+ Fizz


----------------------------------------------------------------------
Ran 4 tests in 0.001s

FAILED (failures=1)
----

*テストおじさん*: ありゃ? `AssertionError: 'FizzBuzz' != 'Fizz'` 期待した値と違うな。

該当コードにブレークポイントを設定したデバッガを起動するテストおじさん。

[source, Python]
----
def execute():
    n = 100
    while n != 0:
        if n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        elif n % 3 == 0 and n % 5 == 0: <1>
            print("FizzBuzz")
        else:
            print(n)
        n = n - 1
----

*テストおじさん*: 100から評価されるのか・・・15までステップ実行のめんどくさいな(´Д｀)ﾊｧ…

*テストおじさん*: 90も3と5で割り切れるよな。

[source, Python]
----
def execute():
    n = 100
    while n != 0:
        if n % 3 == 0: <2>
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        elif n % 3 == 0 and n % 5 == 0: <1>
            print("FizzBuzz")
        else:
            print(n)
        n = n - 1
----

*テストおじさん*: あー90なら3で割り切れるからFizzを先に返すわな。

*テストおじさん*: ここはこうで・・・

[source, Python]
----
def execute():
    n = 100
    while n != 0:
        if n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        elif n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
        n = n - 1
----

*テストおじさん*: こう!

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (__main__.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (__main__.MainTest) ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK
----

*テストおじさん*: このように判断の順番によって結果が変わるコードは [red]#結合度# が高いコードと言われます。

*テストおじさん*: [red]#結合度# できだけ疎結合であることが理想なんですけどね。

*テストおじさん*: [red]#明白な実装# により最後の [red]#TODOリスト# も片付けることができました。

* [x] 1 から 100 まで数をプリントできるようにする。
* [x] 3 の倍数のときは数の代わりに｢Fizz｣をプリントできるようにする。
* [x] 5 の倍数のときは｢Buzz｣とプリントできるようにする。
* [x] 3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントできるようにする。

[quote, 'https://amzn.to/2QtCA5b[テスト駆動開発]']
____
明白な実装

シンプルな操作を実現するにはどうすればいいだろうか----そのまま実装しよう。

仮実装や三角測量は、細かく細かく刻んだ小さなステップだ。だが、ときには実装をどうすべきか既に見えていることが。
そのまま進もう。例えば先ほどのplusメソッドくらいシンプルなものを仮実装する必要が本当にあるだろうか。
普通は、その必要はない。頭に浮かんだ明白な実装をただ単にコードに落とすだけだ。もしもレッドバーが出て驚いたら、あらためてもう少し歩幅を小さくしよう。
____

==== アーキテクチャ

*テスト初めて書いたひと*: 実際のアプリケーションだといろいろなプログラムや外部モジュールやサービスと連携されてますけど全部同じようにテストするんですか?

*テストおじさん*: 確かに全部同じように実施するのは現実的ではありませんよね。

*テストおじさん*: [red]#製品アーキテクチャ# というのがあります。

[quote]
____
製品アーキテクチャとは、普通に訳すと「基本設計思想」ですが、それを経営戦略に応用すると、
「どのようにして製品を構成部品の単位に分解し、そこに製品機能を配分し、それによって必要となる部品間のインターフェース（つなぎ目）をいかに設計・調整するか」を意味します。

代表的な分類として、「モジュール型」「インテグラル型」があり、また「クローズ型」と「オープン型」に分けられます。
____

*テストおじさん*: 構成部品が今書いているプログラムに該当しますかね。

*テストおじさん*: 構成部品はテスト駆動で作り込みます。

*テストおじさん*: 部品間のインターフェース（つなぎ目）の設計もテスト駆動が適用できます。

*テスト鬼さん*: AWSのS3サービスと連携させる場合は自動テスト実行時に毎回呼び出したりするんですか?

*テストおじさん*: 独立したサービスの連携をテストする場合には [red]#Mock Object（偽装オブジェクト）パターン# を使って振る舞いを差し替えたります。

[quote, 'https://amzn.to/2QtCA5b[テスト駆動開発]']
____
Mock Object（偽装オブジェクト）パターン

構築処理が重かったり、準備に手間がかかったりするようなリソースに依存したオブジェクトをテストするにはどうすればよいだろうか----決められた結果を返す、偽物のオブジェクトを代わりに作成しよう。
____

*テスト初めて書いたひと*: スタブやドライバと言うやつですね。

*テストおじさん*: そうですね、TDD界隈では以下に分類されているそうです。

[plantuml]
----
class TestDouble
TestDouble <|-- Dummy
TestDouble <|-- Spy
TestDouble <|-- Stub
TestDouble <|-- Mock
TestDouble <|-- Fake
----

*テストおじさん*: [red]#製品アーキテクチャ# というのは主に製造業の分野の考えですがソフトウェアにもあります。

*テストおじさん*: そのソフトウェア分野でアーキテクチャに関して [red]#エンタープライズアプリケーションアーキテクチャパターン# ではこう言及されてます。

[quote, 'https://amzn.to/2QMAUUu[エンタープライズ アプリケーションアーキテクチャパターン (Object Oriented SELECTION)]']
____
アーキテクチャ

アーキテクチャは、多くの人が定義しようとして、なかなか同意に至らない用語である。
この用語には誰もが認める２つの要素があるという。１つは、システムから個々のパーツへとどこまでもブレークダウンできるということ、もう１つは、簡単には変更できない決定事項だということである。
また、次第に理解されてきたことだが、システムのアーキテクチャのあり方は１つだけでなく、１つのシステムには複数のアーキテクチャがあり、アーキテクチャにとって重要なことはシステムの存続期間の中で変わることがある。
____

*テストおじさん*: 私はいわゆる [red]#エンタープライズアプリケーション# 分野の人です。

[quote, 'https://amzn.to/2QMAUUu[エンタープライズ アプリケーションアーキテクチャパターン (Object Oriented SELECTION)]']
____
エンタープライズアプリケーション

エンタープライズアプリケーションには、給与計算、診療記録、出荷管理、コスト分析、信用調査、保険、サプライチェーン、会計、顧客サービス、外国為替取引などが含まれる。
一方、自動車用燃料噴射、ワープロ、エレベータ制御、化学プラント制御、化学プラント制御、電話交換、OS,コンパイラ、ゲームはエンタープライズアプリケーションに含まれない。
____

*テストおじさん*: [red]#エンタープライズアプリケーション# の特徴として以下の物があります。

* 永続データを伴う。
* たくさんのデータを扱う。
* 多くのユーザが同時にデータにアクセスする。
* 多くのユーザインターフェース画面がある。
* 他のエンタープライズアプリケーションと統合する必要がある。

*テストおじさん*: その [red]#エンタープライズアプリケーション# をWebベースで作るときにはWebアプリケーションフレームワークを使うことでテストする範囲を狭めることができます。

*テストおじさん*: Webプレゼンテーションパターンの [red]#モデルビューコントローラ# を実装したWebアプリケーションフレームワークに https://rubyonrails.org/[Ruby on Rails] や https://www.djangoproject.com/[Django] があります。

[quote, 'https://amzn.to/2QMAUUu[エンタープライズ アプリケーションアーキテクチャパターン (Object Oriented SELECTION)]']
____
モデルビューコントローラ

ユーザインターフェースの相互作用を３つの明確な役割へ分割する。
____

*テストおじさん*: こうしたWebアプリケーションを導入することで業務ロジックに集中してテスト駆動開発を進めることができます。

*テストおじさん*: まあ、フレームワークに習熟しないといけないし癖もありますけどね・・・

=== リファクタリングから始める構造化プログラミング

==== 重複したコード

*テストおじさん*: さて、仕様を満たすプログラムはできましたがまだ完了ではありません。

*テストおじさん*: リファクタリングの時間です!

*テスト初めて書いたひと*: [red]#コードの不吉な臭い# ですね。

[quote, 'https://amzn.to/2T3Jek7[新装版 リファクタリング―既存のコードを安全に改善する― (OBJECT TECHNOLOGY SERIES) ]']
____
コードの不吉な臭い

* 重複したコード
* 長過ぎるコード
* 巨大なクラス
* 長すぎるパラメータリスト
* 変更の偏り
* 変更の分散
* 特性の横恋慕
* データの群れ
* 基本データ型への執着
* スイッチ文
* パラレル継承
* 怠け者クラス
* 疑わしき一般化
* 一時的属性
* メッセージの連鎖
* 仲介人
* 不適切な関係
* クラスのインタフェース不一致
* 未成熟なクラスライブラリ
* データクラス
* 相続拒否
* コメント
____

*テストおじさん*: イエス! その前に [red]#リファクタリングのヒント# からチェックしてみましょう。

*テストおじさん*: テストに関してはどうですかね。

[quote, 'https://amzn.to/2T3Jek7[新装版 リファクタリング―既存のコードを安全に改善する― (OBJECT TECHNOLOGY SERIES) ]']
____
リファクタリングのヒント

* [x] 構造的に機能を付け加えにくいプログラムに、新規機能を追加しなければならない場合には、まず機能追加が簡単になるようにリファクタリングをしてから追加を行うこと。

* [x] リファクタリングに入る前に、しっかりとした一連のテスト群が用意できているかを確認すること。これらのテストには自己診断機能が不可欠である。

* [ ] リファクタリングでは小さなステップでプログラムを変更していく。そのため、誤ったことしても、バグを見つけるのは簡単である。

* [ ] コンパイラが理解出るコードは誰にでも書ける。すぐれたプログラマは、人間にとってわかりやすいコードを書く。

* [ ] リファクタリング（名詞）：外側から見たときの振る舞いを保ちつつ、理解や修正が簡単になるように、ソフトウェアの内部構造を変化させること。

* [ ] リファクタリングする（動詞）：一連のリファクタリングを適用して、外部から見た振る舞いの変更なしに、ソフトウェアを再構築すること。

* [ ] ３三度目になったらリファクタリング開始。

* [ ] あまり早期にインタフェースを公開しないこと。スムーズなリファクタリングのために、時にはコードの所有権のポリシーを変えることも必要。

* [ ] コメントの必要を感じたときにはリファクタリングを行って、コメントを書かなくとも内容がわかるようなコードを目指すこと。

* [ ] テストを完全に自動化して、その結果もテストにチェックさせること。

* [x] テストをひとそろいにしておくと、バグの検出に絶大な威力を発揮する。これによって、バグの発見にかかる時間は削除される。
____

コードを眺めるテストおじさん。

[source, Python]
----
class MainTest(unittest.TestCase):
    def test_1から100まで数をプリントできるようにする(self):
        with captured_stdout() as stdout:
            execute()
            lines = stdout.getvalue().splitlines()

        self.assertEqual("1", lines[99])
        self.assertEqual("Buzz", lines[0])

    def test_3の倍数のときは数の代わりにFizzをプリントする(self):
        with captured_stdout() as stdout:
            execute()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("Fizz", lines[97])

    def test_5の倍数のときはBuzzとプリントする(self):
        with captured_stdout() as stdout:
            execute()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("Buzz", lines[95])

    def test_3と5両方の倍数の場合にはFizzBuzzとプリントする(self):
        with captured_stdout() as stdout:
            execute()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("FizzBuzz", lines[85])
----

*テストおじさん*: テストコードに [red]#重複したコード# がありますね。

*テストおじさん*: [red]#メソッドの抽出# を実施して [red]#フィクスチャー# にまとめましょう。

[quote, 'https://amzn.to/2T3Jek7[新装版 リファクタリング―既存のコードを安全に改善する― (OBJECT TECHNOLOGY SERIES) ]']
____
メソッドの抽出

ひとまとめにできるコードの断片がある。

コードの断片をメソッドにして、それに目的を表すような名前をつける。
____

[quote, 'https://amzn.to/2QtCA5b[テスト駆動開発]']
____
フィクスチャー

複数のテストから使われる共通のオブジェクトを作るにはどうしたらよいだろうか---テストメソッド内のローカル変数をインスタンス変数に引き上げ、オーバーライドしたsetUpメソッドの中で初期化を行う。
____

[source, Python]
----
class MainTest(unittest.TestCase):
    def setUp(self):
        with captured_stdout() as stdout:
            execute()
            self.lines = stdout.getvalue().splitlines()

    def test_1から100まで数をプリントできるようにする(self):
        self.assertEqual("1", self.lines[99])
        self.assertEqual("Buzz", self.lines[0])

    def test_3の倍数のときは数の代わりにFizzをプリントする(self):
        self.assertEqual("Fizz", self.lines[97])

    def test_5の倍数のときはBuzzとプリントする(self):
        self.assertEqual("Buzz", self.lines[95])

    def test_3と5両方の倍数の場合にはFizzBuzzとプリントする(self):
        self.assertEqual("FizzBuzz", self.lines[85])
----

*テストおじさん*: プログラムが壊れてないか確認しましょう。

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (__main__.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (__main__.MainTest) ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK
----

*テストおじさん*: 大丈夫ですね。

==== ベイビーステップ

*テストおじさん*: 続いてプロダクトコードに関してはどうですかね。

[quote, 'https://amzn.to/2T3Jek7[新装版 リファクタリング―既存のコードを安全に改善する― (OBJECT TECHNOLOGY SERIES) ]']
____
リファクタリングのヒント

* [x] 構造的に機能を付け加えにくいプログラムに、新規機能を追加しなければならない場合には、まず機能追加が簡単になるようにリファクタリングをしてから追加を行うこと。

* [x] リファクタリングに入る前に、しっかりとした一連のテスト群が用意できているかを確認すること。これらのテストには自己診断機能が不可欠である。

* [ ] リファクタリングでは小さなステップでプログラムを変更していく。そのため、誤ったことしても、バグを見つけるのは簡単である。

* [x] コンパイラが理解出るコードは誰にでも書ける。すぐれたプログラマは、人間にとってわかりやすいコードを書く。

* [ ] リファクタリング（名詞）：外側から見たときの振る舞いを保ちつつ、理解や修正が簡単になるように、ソフトウェアの内部構造を変化させること。

* [ ] リファクタリングする（動詞）：一連のリファクタリングを適用して、外部から見た振る舞いの変更なしに、ソフトウェアを再構築すること。

* [ ] ３三度目になったらリファクタリング開始。

* [ ] あまり早期にインタフェースを公開しないこと。スムーズなリファクタリングのために、時にはコードの所有権のポリシーを変えることも必要。

* [ ] コメントの必要を感じたときにはリファクタリングを行って、コメントを書かなくとも内容がわかるようなコードを目指すこと。

* [ ] テストを完全に自動化して、その結果もテストにチェックさせること。

* [x] テストをひとそろいにしておくと、バグの検出に絶大な威力を発揮する。これによって、バグの発見にかかる時間は削除される。
____

コードを眺めるテストおじさん。

[source, Python]
----
def execute():
    n = 100
    while n != 0: <1>
        if n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        elif n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        else:
            print(n)
        n = n - 1
----

*テストおじさん*: 1から100までをプリントするのに100から処理を開始していますね。

[source, Python]
----
    def test_1から100まで数をプリントできるようにする(self):
        self.assertEqual("1", self.lines[99])
        self.assertEqual("Buzz", self.lines[0])
----

*テストおじさん*: 結果をリストに保存していますが1に対応するリストの添字が99って分かりづらいですよね。

*テスト初めて書いたひと*: たしかにそうですね。

*テストおじさん*: こういう時はまずこうしてみましょう。

[source, Python]
----
def execute():
    n = 1
    while n != 100: <1>
        if n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        elif n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
        n = n - 1
----

*テストおじさん*: はい、確認・・・ありゃ？

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ...
----

テストを `Ctr-c` で強制停止した後、デバッガを起動してステップ実行するテストおじさん。

*テストおじさん*: あー `n = n - 1` では `n != 100` の条件に到達することは永久にないっすね。

[source, Python]
----
def execute():
    n = 1
    while n != 100: <1>
        if n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        elif n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
        n = n - 1 <2>
----

*テストおじさん*: ここはこうかな。

[source, Python]
----
def execute():
    n = 1
    while n != 100:
        if n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        elif n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
        n = n + 1
----

*テストおじさん*: テスト!・・・ファッ!!

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ERROR
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (__main__.MainTest) ... FAIL
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... FAIL
test_5の倍数のときはBuzzとプリントする (__main__.MainTest) ... FAIL

======================================================================
ERROR: test_1から100まで数をプリントできるようにする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 26, in test_1から100まで数をプリントできるようにする
    self.assertEqual("1", self.lines[99])
IndexError: list index out of range

======================================================================
FAIL: test_3と5両方の倍数の場合にはFizzBuzzとプリントする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 36, in test_3と5両方の倍数の場合にはFizzBuzzとプリントする
    self.assertEqual("FizzBuzz", self.lines[85])
AssertionError: 'FizzBuzz' != '86'
- FizzBuzz
+ 86


======================================================================
FAIL: test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 30, in test_3の倍数のときは数の代わりにFizzをプリントする
    self.assertEqual("Fizz", self.lines[97])
AssertionError: 'Fizz' != '98'
- Fizz
+ 98


======================================================================
FAIL: test_5の倍数のときはBuzzとプリントする (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "main_test.py", line 33, in test_5の倍数のときはBuzzとプリントする
    self.assertEqual("Buzz", self.lines[95])
AssertionError: 'Buzz' != 'Fizz'
- Buzz
+ Fizz


----------------------------------------------------------------------
Ran 4 tests in 0.001s

FAILED (failures=3, errors=1)
----

*テストおじさん*: テストが全部失敗してしまいましたね。

*テストおじさん*: こういう時は落ち着いて一つづつ確認していきましょう。

[quote, 'https://amzn.to/2T3Jek7[新装版 リファクタリング―既存のコードを安全に改善する― (OBJECT TECHNOLOGY SERIES) ]']
____
リファクタリングのヒント

* [x] 構造的に機能を付け加えにくいプログラムに、新規機能を追加しなければならない場合には、まず機能追加が簡単になるようにリファクタリングをしてから追加を行うこと。

* [x] リファクタリングに入る前に、しっかりとした一連のテスト群が用意できているかを確認すること。これらのテストには自己診断機能が不可欠である。

* [x] リファクタリングでは小さなステップでプログラムを変更していく。そのため、誤ったことしても、バグを見つけるのは簡単である。

* [x] コンパイラが理解出るコードは誰にでも書ける。すぐれたプログラマは、人間にとってわかりやすいコードを書く。

* [ ] リファクタリング（名詞）：外側から見たときの振る舞いを保ちつつ、理解や修正が簡単になるように、ソフトウェアの内部構造を変化させること。

* [ ] リファクタリングする（動詞）：一連のリファクタリングを適用して、外部から見た振る舞いの変更なしに、ソフトウェアを再構築すること。

* [ ] ３三度目になったらリファクタリング開始。

* [ ] あまり早期にインタフェースを公開しないこと。スムーズなリファクタリングのために、時にはコードの所有権のポリシーを変えることも必要。

* [ ] コメントの必要を感じたときにはリファクタリングを行って、コメントを書かなくとも内容がわかるようなコードを目指すこと。

* [ ] テストを完全に自動化して、その結果もテストにチェックさせること。

* [x] テストをひとそろいにしておくと、バグの検出に絶大な威力を発揮する。これによって、バグの発見にかかる時間は削除される。
____

[source, bash]
----
 $ python -m unittest main_test.MainTest.test_1から100まで数をプリントできるようにする
E
======================================================================
ERROR: test_1から100まで数をプリントできるようにする (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 26, in test_1から100まで数をプリントできるようにする
    self.assertEqual("1", self.lines[99])
IndexError: list index out of range

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (errors=1)
----

*テストおじさん*: `IndexError: list index out of range` リストの100番目に値が存在しないってこと?

コードを眺めるテストおじさん。

[source, Python]
----
def execute():
    n = 1
    while n != 100: <1>
        if n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        elif n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
        n = n + 1
----

*テストおじさん*: あー `while n != 100` だと100は含まれないわな。

*テストおじさん*: だから、ここはこうね。

[source, Python]
----
def execute():
    n = 1
    while n != 101: <1>
        if n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        elif n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
        n = n + 1
----

*テストおじさん*: こうするとどうかな?

[source, bash]
----
$ python -m unittest main_test.MainTest.test_1から100まで数をプリントできるようにする
F
======================================================================
FAIL: test_1から100まで数をプリントできるようにする (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 26, in test_1から100まで数をプリントできるようにする
    self.assertEqual("1", self.lines[99])
AssertionError: '1' != 'Buzz'
- 1
+ Buzz


----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
----

*テストおじさん*: `IndexError: list index out of range` は解決しましたね。

*テストおじさん*: `AssertionError: '1' != 'Buzz'` はリストの最後を評価しているのでこうすればリストの最初の評価になります。

[source, Python]
----
    def test_1から100まで数をプリントできるようにする(self):
        self.assertEqual("1", self.lines[0])
        self.assertEqual("Buzz", self.lines[99])
----

*テストおじさん*: これでどうですかね・・・オッケー!

[source, bash]
----
$ python -m unittest main_test.MainTest.test_1から100まで数をプリントできるようにする
.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
----

*テストおじさん*: 残りのテストもリストの添字が原因のようなので修正しましょう。

[source, Python]
----
class MainTest(unittest.TestCase):
    def setUp(self):
        with captured_stdout() as stdout:
            execute()
            self.lines = stdout.getvalue().splitlines()

    def test_1から100まで数をプリントできるようにする(self):
        self.assertEqual("1", self.lines[0])
        self.assertEqual("Buzz", self.lines[99])

    def test_3の倍数のときは数の代わりにFizzをプリントする(self):
        self.assertEqual("Fizz", self.lines[2])

    def test_5の倍数のときはBuzzとプリントする(self):
        self.assertEqual("Buzz", self.lines[4])

    def test_3と5両方の倍数の場合にはFizzBuzzとプリントする(self):
        self.assertEqual("FizzBuzz", self.lines[14])
----

*テストおじさん*: 確認、確認。

[source, bash]
----
$ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (__main__.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (__main__.MainTest) ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK
----

*テストおじさん*: このようにリファクタリングは [red]#ベイビーステップ# で進めて行くことに留意してください。

[quote, 'https://amzn.to/2Qvx5ms[エクストリームプログラミング]']
____
ベイビーステップ（Baby Steps)

大きな変更は、大きなステップでやりたくなるものである。距離が長く、時間を書けずにそこまで行くとなれば、そうするしかないように思える。だが、重大な変更を一気に行うのは危険だ。変更を頼まれるのは人間である。変更は不安が伴う。不安を伴えば、人間は変更をすばやくやろうとする。
____

==== 学習用テスト

*テストおじさん*: [red]#while文# を使った繰り返し処理では無限ループが発生する恐れがありますよね。

*テストおじさん*: [red]#for文# に書き換えて無限ループが発生しないようにしておきましょう。

*テストおじさん*: 皆さん同様、私もPythonは詳しくないので [red]#学習用テスト# を使って [red]#for文# の振る舞いを確認して見ましょう。

*テストおじさん*: 1から5まで [red]#for文# で出力するにはこんな感じかな。

[source, Python]
----
def execute_for():
    for n in [1, 2, 3, 4, 5]:
        print(n)


class MainTest(unittest.TestCase):
    def test_execute_for(self):
        with captured_stdout() as stdout:
            execute_for()
            lines = stdout.getvalue().splitlines()
        self.assertTrue(1, lines[0])
        self.assertTrue(4, lines[-1])
----

*テストおじさん*: （学習用）テスト。

[source, bash]
----
$ python -m unittest main_test.MainTest.test_execute_for
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
----

*テストおじさん*: [red]#リスト# だとこうすると失敗するのよね。

[source, Python]
----
def execute_for():
    list = [1, 2, 3, 4, 5]
    list[4] = 6
    for n in list:
        print(n)
----

[source, bash]
----
$ python -m unittest main_test.MainTest.test_execute_for
F
======================================================================
FAIL: test_execute_for (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 32, in test_execute_for
    self.assertEqual("5", lines[-1])
AssertionError: '5' != '6'
- 5
+ 6


----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
----

*テストおじさん*: こういう時は [red]#タプル# を使います。

[source, Python]
----
def execute_for():
    tuple = (1, 2, 3, 4, 5)
    tuple[4] = 6
    for n in tuple:
        print(n)
----

[source, bash]
----
$ python -m unittest main_test.MainTest.test_execute_for
E
======================================================================
ERROR: test_execute_for (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 28, in test_execute_for
    execute_for()
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 21, in execute_for
    tuple[4] = 6
TypeError: 'tuple' object does not support item assignment

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (errors=1)
----

*テストおじさん*: `TypeError: 'tuple' object does not support item assignment` と怒られますね。

*テストおじさん*: これで、オッケー。

[source, Python]
----
def execute_for():
    tuple = (1, 2, 3, 4, 5)
    for n in tuple:
        print(n)
----

[source, bash]
----
$ python -m unittest main_test.MainTest.test_execute_for
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
----

*テストおじさん*: あとは100まで入力すれば・・・ってそれは現実的ではありませんよね。

*テストおじさん*: そんな時は [red]#レンジ# を使います。

[source, Python]
----
def execute_for():
    for n in range(100):
        print(n)

class MainTest(unittest.TestCase):
    def test_execute_for(self):
        with captured_stdout() as stdout:
            execute_for()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("1", lines[0])
        self.assertEqual("100", lines[-1])
----

*テストおじさん*: （学習用）テスト。

[source, bash]
----
$ python -m unittest main_test.MainTest.test_execute_for
F
======================================================================
FAIL: test_execute_for (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 28, in test_execute_for
    self.assertEqual("1", lines[0])
AssertionError: '1' != '0'
- 1
+ 0


----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
----

*テストおじさん*: これでどうよ?

[source, Python]
----
def execute_for():
    for n in range(100):
        print(n)

class MainTest(unittest.TestCase):
    def test_execute_for(self):
        with captured_stdout() as stdout:
            execute_for()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("1", lines[1])
        self.assertEqual("100", lines[-1])
----

*テストおじさん*: （学習用）テスト。

[source, bash]
----
$ python -m unittest main_test.MainTest.test_execute_for
F
======================================================================
FAIL: test_execute_for (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 29, in test_execute_for
    self.assertEqual("100", lines[-1])
AssertionError: '100' != '99'
- 100
+ 99


----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
----

*テストおじさん*: えーと、今度は `AssertionError: '100' != '99'` ・・・ [red]#レンジ# は指定した値は範囲に含まないんですね。

*テストおじさん*: ということは、こうして。

[source, Python]
----
def execute_for():
    for n in range(101):
        print(n)


class MainTest(unittest.TestCase):
    def test_execute_for(self):
        with captured_stdout() as stdout:
            execute_for()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("1", lines[1])
        self.assertEqual("100", lines[-1])
----

*テストおじさん*: こう。

[source, bash]
----
$ python -m unittest main_test.MainTest.test_execute_for
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
----

*テストおじさん*: [red]#レンジ# を使うことで1から100までの出力を簡単にすることができるようになりました。

*テストおじさん*: せっかくなので [red]#レンジ# の [red]#学習用テスト# を別途作成してみましょう。

[source, Python]
----
class RangeTest(unittest.TestCase):
    def test_範囲を示すレンジ(self):
        rg = range(10)
        self.assertEqual(0, rg[0])
        self.assertEqual(9, rg[-1])
        rg = range(5, 10)
        self.assertEqual(5, rg[0])
        self.assertEqual(9, rg[-1])
        rg = range(10, 20, 2)
        self.assertEqual(12, rg[1])
        self.assertEqual(18, rg[-1])

    def test_レンジのシーケンス演算(self):
        rg = range(30)
        self.assertTrue(10 in rg)
        self.assertTrue(30 not in rg)
        rg = range(50)
        self.assertEqual(range(1, 4), rg[1:4])
        self.assertEqual(50, len(rg))
        self.assertEqual(49, max(rg))
        self.assertEqual(0, min(rg))

    def test_シーケンス間の変換(self):
        list1 = [100, 200, 300]
        tpl1 = (123, 'ok', True)
        rng1 = range(10, 20)
        result = list1 + list(tpl1) + list(rng1)
        self.assertEqual([100, 200, 300, 123, 'ok', True, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], result)
----

*テストおじさん*: レンジの学習用テストだけ実行する場合はこうですね。

[source, bash]
----
$ python -m unittest main_test.RangeTest -v
test_シーケンス間の変換 (main_test.RangeTest) ... ok
test_レンジのシーケンス演算 (main_test.RangeTest) ... ok
test_範囲を示すレンジ (main_test.RangeTest) ... ok

----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK
----

==== アルゴリズムの取り替え

*テストおじさん*: [red]#学習用テスト# で [red]#for文# と [red]#レンジ# の使い方がわかったので [red]#アルゴリズムの取り替え# を実施しましょう。

[quote, 'https://amzn.to/2T3Jek7[新装版 リファクタリング―既存のコードを安全に改善する― (OBJECT TECHNOLOGY SERIES) ]']
____
アルゴリズムの取り替え

アルゴリズムをよりわかりやすいものに置き換えたい。

メソッドの本体を新たなアルゴリズムで置き換える。
____

*テストおじさん*: まずは [red]#学習用テスト# 関数を使って [red]#明白な実装# をします。

[source, Python]
----
def execute_for():
    for n in range(101):
        if n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        elif n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
        n = n + 1



class MainTest(unittest.TestCase):
    def test_execute_for(self):
        with captured_stdout() as stdout:
            execute_for()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("1", lines[1])
        self.assertEqual("100", lines[-1])
----

*テストおじさん*: どうかな?

[source, bash]
----
$ python -m unittest main_test.MainTest.test_execute_for
F
======================================================================
FAIL: test_execute_for (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 39, in test_execute_for
    self.assertEqual("100", lines[-1])
AssertionError: '100' != 'Buzz'
- 100
+ Buzz


----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
----

*テストおじさん*: `AssertionError: '100' != 'Buzz'` ・・・あー100は5で割り切れるからこれはテストが間違っているね。

*テストおじさん*: いや、設計の仕様が間違っているかな。

[source, Python]
----
    def test_execute_for(self):
        with captured_stdout() as stdout:
            execute_for()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("1", lines[1])
        self.assertEqual("Buzz", lines[-1]) <1>
----

*テストおじさん*: これで・・・オッケー。

[source, bash]
----
$ python -m unittest main_test.MainTest.test_execute_for
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
----

*テストおじさん*: `n = n + 1` の [red]#変数# への代入は不要なので削除して。

[source, Python]
----
def execute_for():
    for n in range(101):
        if n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        elif n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
----

*テストおじさん*: プログラムは壊れてないよね。

[source, bash]
----
$ python -m unittest main_test.MainTest.test_execute_for
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
k2works-mbp-pro@k2works:replay (feature/2018116_replay) $ python main_test.py -v
test_1から100まで数をプリントできるようにする (__main__.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (__main__.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (__main__.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (__main__.MainTest) ... ok
test_execute_for (__main__.MainTest) ... ok
test_シーケンス間の変換 (__main__.RangeTest) ... ok
test_レンジのシーケンス演算 (__main__.RangeTest) ... ok
test_範囲を示すレンジ (__main__.RangeTest) ... ok

----------------------------------------------------------------------
Ran 8 tests in 0.001s

OK
----

*テストおじさん*: よし、それでは `execute_for` 関数を `execute` に差し替えましょう。

[source, Python]
----
def execute_for():
    n = 1
    while n != 101:
        if n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        elif n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
        n = n + 1


def execute():
    for n in range(101):
        if n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        elif n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
----

*テストおじさん*: 確認・・・ファッ!

[source, bash]
----
$ python -m unittest main_test.MainTest -v
test_1から100まで数をプリントできるようにする (main_test.MainTest) ... FAIL
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (main_test.MainTest) ... FAIL
test_3の倍数のときは数の代わりにFizzをプリントする (main_test.MainTest) ... FAIL
test_5の倍数のときはBuzzとプリントする (main_test.MainTest) ... FAIL
test_execute_for (main_test.MainTest) ... FAIL

======================================================================
FAIL: test_1から100まで数をプリントできるようにする (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 46, in test_1から100まで数をプリントできるようにする
    self.assertEqual("1", self.lines[0])
AssertionError: '1' != 'FizzBuzz'
- 1
+ FizzBuzz


======================================================================
FAIL: test_3と5両方の倍数の場合にはFizzBuzzとプリントする (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 56, in test_3と5両方の倍数の場合にはFizzBuzzとプリントする
    self.assertEqual("FizzBuzz", self.lines[14])
AssertionError: 'FizzBuzz' != '14'
- FizzBuzz
+ 14


======================================================================
FAIL: test_3の倍数のときは数の代わりにFizzをプリントする (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 50, in test_3の倍数のときは数の代わりにFizzをプリントする
    self.assertEqual("Fizz", self.lines[2])
AssertionError: 'Fizz' != '2'
- Fizz
+ 2


======================================================================
FAIL: test_5の倍数のときはBuzzとプリントする (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 53, in test_5の倍数のときはBuzzとプリントする
    self.assertEqual("Buzz", self.lines[4])
AssertionError: 'Buzz' != '4'
- Buzz
+ 4


======================================================================
FAIL: test_execute_for (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 37, in test_execute_for
    self.assertEqual("1", lines[1])
AssertionError: '1' != '2'
- 1
+ 2


----------------------------------------------------------------------
Ran 5 tests in 0.001s

FAILED (failures=5)
----

*テストおじさん*: またまた、テストが壊れてしまいました。

*テストおじさん*: [red]#ベイビーステップ# [red]#ベイビーステップ# ・・・

テスト結果を眺めるテストおじさん

[source, bash]
----

======================================================================
FAIL: test_1から100まで数をプリントできるようにする (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 46, in test_1から100まで数をプリントできるようにする
    self.assertEqual("1", self.lines[0])
AssertionError: '1' != 'FizzBuzz'
- 1
+ FizzBuzz

======================================================================
FAIL: test_execute_for (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 37, in test_execute_for
    self.assertEqual("1", lines[1])
AssertionError: '1' != '2'
- 1
+ 2
----

*テストおじさん*: `execute` 関数が `AssertionError: '1' != 'FizzBuzz'` で `execute_for` が `AssertionError: '1' != '2'` となってるということは・・・

*テストおじさん*: また [red]#リスト# の添字の問題のようですね。

*テストおじさん*: `execute_for` 関数はこうかな・・・よし!

[source, Python]
----
    def test_execute_for(self):
        with captured_stdout() as stdout:
            execute_for()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("1", lines[0]) <1>
        self.assertEqual("Buzz", lines[-1])
----

[source, bash]
----
$ python -m unittest main_test.MainTest.test_execute_for
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
----

*テストおじさん*: となると `execute` 関数はこうね・・・よし!

[source, Python]
----
    def test_1から100まで数をプリントできるようにする(self):
        self.assertEqual("1", self.lines[1]) <1>
        self.assertEqual("Buzz", self.lines[100]) <2>
----

[source, bash]
----
$ python -m unittest main_test.MainTest.test_1から100まで数をプリントできるようにする
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
----

*テストおじさん*: 残りも同じっすね・・・オッケー!

[source, Python]
----
    def test_3の倍数のときは数の代わりにFizzをプリントする(self):
        self.assertEqual("Fizz", self.lines[3]) <1>

    def test_5の倍数のときはBuzzとプリントする(self):
        self.assertEqual("Buzz", self.lines[5]) <2>

    def test_3と5両方の倍数の場合にはFizzBuzzとプリントする(self):
        self.assertEqual("FizzBuzz", self.lines[15]) <3>
----

[source, bash]
----
$ python -m unittest main_test.MainTest -v
test_1から100まで数をプリントできるようにする (main_test.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (main_test.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (main_test.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (main_test.MainTest) ... ok
test_execute_for (main_test.MainTest) ... ok

----------------------------------------------------------------------
Ran 5 tests in 0.001s

OK
----

*テストおじさん*: 後は不要な `execute_for` 関数を削除して [red]#アルゴリズムの取り替え# 完了です。

*テストおじさん*: プログラムが壊れてないか確認・・・おう!?

[source, bash]
----
$ python -m unittest main_test.MainTest -v
test_1から100まで数をプリントできるようにする (main_test.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (main_test.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (main_test.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (main_test.MainTest) ... ok
test_execute_for (main_test.MainTest) ... ERROR

======================================================================
ERROR: test_execute_for (main_test.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/k2works/Projects/hiroshima-arc/re_zero_tdd/dev/20181116/replay/main_test.py", line 20, in test_execute_for
    execute_for()
NameError: name 'execute_for' is not defined

----------------------------------------------------------------------
Ran 5 tests in 0.001s

FAILED (errors=1)
----

*テストおじさん*: `NameError: name 'execute_for' is not defined` ・・・あー関数を削除したからね。

[source, Python]
----
    def test_execute_for(self):
        with captured_stdout() as stdout:
            execute_for()
            lines = stdout.getvalue().splitlines()
        self.assertEqual("1", lines[0])
        self.assertEqual("Buzz", lines[-1])
----

*テストおじさん*: `test_execute_for` も不要なので削除して確認・・・オッケー!

[source, bash]
----
$ python -m unittest main_test.MainTest -v
test_1から100まで数をプリントできるようにする (main_test.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (main_test.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (main_test.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (main_test.MainTest) ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK
----

==== 長すぎるコード

*テストおじさん*: さて `execute` 関数が実行している内容ですが・・・

コメント追加するテストおじさん。

[source, Python]
----
def execute():
    # 100回繰り返す
    for n in range(101):
        # 3で割り切れたらFizz 5で割り切れたらBuzz 3または5で割り切れたらFizzBuzzをプリントする
        if n % 3 == 0 and n % 5 == 0:
            print("FizzBuzz")
        elif n % 3 == 0:
            print("Fizz")
        elif n % 5 == 0:
            print("Buzz")
        else:
            print(n)
----

*テストおじさん*: コメントが必要になる [red]#長すぎるコード# ですね。

*テストおじさん*: どうやらリファクタリングの必要がありそうです。

[quote, 'https://amzn.to/2T3Jek7[新装版 リファクタリング―既存のコードを安全に改善する― (OBJECT TECHNOLOGY SERIES) ]']
____
リファクタリングのヒント

* [x] 構造的に機能を付け加えにくいプログラムに、新規機能を追加しなければならない場合には、まず機能追加が簡単になるようにリファクタリングをしてから追加を行うこと。

* [x] リファクタリングに入る前に、しっかりとした一連のテスト群が用意できているかを確認すること。これらのテストには自己診断機能が不可欠である。

* [x] リファクタリングでは小さなステップでプログラムを変更していく。そのため、誤ったことしても、バグを見つけるのは簡単である。

* [x] コンパイラが理解出るコードは誰にでも書ける。すぐれたプログラマは、人間にとってわかりやすいコードを書く。

* [ ] リファクタリング（名詞）：外側から見たときの振る舞いを保ちつつ、理解や修正が簡単になるように、ソフトウェアの内部構造を変化させること。

* [ ] リファクタリングする（動詞）：一連のリファクタリングを適用して、外部から見た振る舞いの変更なしに、ソフトウェアを再構築すること。

* [ ] ３三度目になったらリファクタリング開始。

* [ ] あまり早期にインタフェースを公開しないこと。スムーズなリファクタリングのために、時にはコードの所有権のポリシーを変えることも必要。

* [x] コメントの必要を感じたときにはリファクタリングを行って、コメントを書かなくとも内容がわかるようなコードを目指すこと。

* [ ] テストを完全に自動化して、その結果もテストにチェックさせること。

* [x] テストをひとそろいにしておくと、バグの検出に絶大な威力を発揮する。これによって、バグの発見にかかる時間は削除される。
____

*テストおじさん*: まず、繰り返し内部の処理に対して [red]#メソッドの抽出# を実施します。

[source, Python]
----
def execute():
    # 100回繰り返す
    for n in range(101):
        # 3で割り切れたらFizz 5で割り切れたらBuzz 3または5で割り切れたらFizzBuzzをプリントする
        fizz_buzz(n)


def fizz_buzz(n):
    if n % 3 == 0 and n % 5 == 0:
        print("FizzBuzz")
    elif n % 3 == 0:
        print("Fizz")
    elif n % 5 == 0:
        print("Buzz")
    else:
        print(n)
----

*テストおじさん*: 変更したら、確認です。

[source, bash]
----
$ python -m unittest main_test.MainTest -v
test_1から100まで数をプリントできるようにする (main_test.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (main_test.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (main_test.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (main_test.MainTest) ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK
----

*テストおじさん*: 繰り返し部分も同様に。

[source, Python]
----
def execute():
    # 100回繰り返す
    iterate(101)


def iterate(c):
    for n in range(c):
        # 3で割り切れたらFizz 5で割り切れたらBuzz 3または5で割り切れたらFizzBuzzをプリントする
        fizz_buzz(n)


def fizz_buzz(n):
    if n % 3 == 0 and n % 5 == 0:
        print("FizzBuzz")
    elif n % 3 == 0:
        print("Fizz")
    elif n % 5 == 0:
        print("Buzz")
    else:
        print(n)
----

*テストおじさん*: 大丈夫・・・ですね。

[source, bash]
----
$ python -m unittest main_test.MainTest -v
test_1から100まで数をプリントできるようにする (main_test.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (main_test.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (main_test.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (main_test.MainTest) ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK
----

==== 説明用変数の導入

*テストおじさん*: さて [red]#メソッドの抽出# により見通しの良いコードになりましたが・・・・

コードを眺めるテストおじさん。

[source, Python]
----
def execute():
    # 100回繰り返す
    iterate(101)


def iterate(c):
    for n in range(c):
        # 3で割り切れたらFizz 5で割り切れたらBuzz 3または5で割り切れたらFizzBuzzをプリントする
        fizz_buzz(n)


def fizz_buzz(n):
    if n % 3 == 0 and n % 5 == 0:
        print("FizzBuzz")
    elif n % 3 == 0:
        print("Fizz")
    elif n % 5 == 0:
        print("Buzz")
    else:
        print(n)
----

*テストおじさん*: [red]#関数# の間で `n` や `c` といった [red]#変数# を使っていますがパット見なにか分かりづらいですね。

*テストおじさん*: [red]#説明変数の導入# を導入して読みやすいコードにしましょう。

[quote, 'https://amzn.to/2T3Jek7[新装版 リファクタリング―既存のコードを安全に改善する― (OBJECT TECHNOLOGY SERIES) ]']
____
説明用変数の導入

複雑な式がある。

その式の結果または部分的な結果を、その目的を説明する名前をつけた一時変数に代入する。
____

*テストおじさん*: `count` と `number` という変数名に変更しましょう。

[source, Python]
----
def execute():
    # 100回繰り返す
    count = 101
    iterate(count)


def iterate(count):
    for number in range(count):
        # 3で割り切れたらFizz 5で割り切れたらBuzz 3または5で割り切れたらFizzBuzzをプリントする
        fizz_buzz(number)


def fizz_buzz(number):
    if number % 3 == 0 and number % 5 == 0:
        print("FizzBuzz")
    elif number % 3 == 0:
        print("Fizz")
    elif number % 5 == 0:
        print("Buzz")
    else:
        print(number)
----

*テストおじさん*: テスト・・・オッケー。

[source, bash]
----
 $ python -m unittest main_test.MainTest -v
test_1から100まで数をプリントできるようにする (main_test.MainTest) ... ok
test_3と5両方の倍数の場合にはFizzBuzzとプリントする (main_test.MainTest) ... ok
test_3の倍数のときは数の代わりにFizzをプリントする (main_test.MainTest) ... ok
test_5の倍数のときはBuzzとプリントする (main_test.MainTest) ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK
----

== ふりかえり
[source, Markdown]
----
include::../../../dev/20181116/replay/README.md[]
----

[source, Python]
----
include::../../../dev/20181116/replay/main_test.py[]
----


==== Keep

==== Problem

==== Try

== 参照

=== 参考図書

++++
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=k2works0c-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=4274217884&linkId=568f25b974af5645e862928a12c354e1&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=k2works0c-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=427405019X&linkId=08e705a5969e20f5129b4d3cefbcdb15&bc1=000000&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=k2works0c-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=4798105538&linkId=12f5983ecb6ad915457406c2fd0d89ed&bc1=000000&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=k2works0c-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=4274217620&linkId=59f5959cf4575e61b0eeb1afc17b1715&bc1=000000&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"></iframe>
++++

=== 参考リンク

* https://www.buildinsider.net/enterprise/agile/01[アジャイルとは何か？ ツールと開発手法「スクラム／XP」、ウォーターフォールとの違い]
* https://globis.jp/article/2046[MBA経営辞書「製品アーキテクチャ」]
* http://www.itmedia.co.jp/im/articles/1111/07/news183.html[テストドライバ（てすとどらいば）]
